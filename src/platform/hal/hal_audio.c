#include <platform.h>
#include <mss_gpio.h>
#include <Control_IO.h>

#define SOCK_0			{hal_gpio_output(AMBE_SOCK, 0);}
#define SOCK_1			{hal_gpio_output(AMBE_SOCK, 1);}

#define SICK_0			{hal_gpio_output(AMBE_SICK, 0);}
#define SICK_1			{hal_gpio_output(AMBE_SICK, 1);}

#define SDI_0			{hal_gpio_output(AMBE_SDI, 0);}
#define SDI_1			{hal_gpio_output(AMBE_SDI, 1);}

#define SISTRB_0		{hal_gpio_output(AMBE_SISTRB, 0);}
#define SISTRB_1		{hal_gpio_output(AMBE_SISTRB, 1);}

#define SOSTRB_0		{hal_gpio_output(AMBE_SOSTRB, 0);}
#define SOSTRB_1		{hal_gpio_output(AMBE_SOSTRB, 1);}

#define AMBE_RST_0		{hal_gpio_output(AMBE_RST, 0);}
#define AMBE_RST_1		{hal_gpio_output(AMBE_RST, 1);}

#define SDO_STATE		(hal_gpio_input(AMBE_SDO))

#define EPR_PIN_STATE   (hal_gpio_input(AMBE_EPR))

#define DPE_PIN_STATE   (hal_gpio_input(AMBE_DPE))

static uint8_t audio_num_per_frm = 6;
static uint8_t audio_rate = VOICE_2400BPS_LEVEL;

const uint8_t slience_enforce_voice[VOICE_MAX_LEVEL][AUDIO_FRAME_SIZE] = 
{
	//0000
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBC,0xA8,0xC2,0x42,0x72,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//0001
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB7,0x78,0x69,0xE0,0x86,0xC3,0x40,0x14,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//0010
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x96,0xBB,0xC9,0xDE,0x33,0x49,0x19,0x01,0x12,0x59,0xF2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//0011
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA5,0xD4,0x82,0xAC,0xE8,0x21,0x69,0x01,0x4C,0x07,0x64,0x8C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//0100
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x44,0xD4,0x16,0x88,0x4B,0xA0,0x22,0xEA,0x02,0x2A,0x85,0x41,0x82,0x21,0x8A,0x67,0x87,0x23,0x0E,0x63,0xA8,0x82,0x8A},
	//0101
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAC,0xA8,0xE0,0x41,0x63,0x4B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//0110
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF5,0x53,0x8E,0xA7,0xA0,0x0F,0xD6,0x01,0xDC,0x40,0x0A,0x31,0x6D,0xA0,0x3E,0x6D,0x35,0x52,0x15,0x29,0x59,0x9E,0xCC,0xB8}, 
	//0111
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x93,0xF7,0x93,0xB2,0xC4,0x26,0x55,0x05,0x29,0x68,0x20,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//1000
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF7,0x88,0xA8,0xC7,0xCC,0x12,0x61,0x2A,0x30,0x02,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//1001
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFB,0x88,0xC1,0xA9,0xED,0x63,0xDD,0xA0,0x62,0x64,0x83,0xED,0x31,0x31,0x4A,0x5C,0xED,0xE6,0x00,0x00,0x00,0x00,0x00,0x00},
	//1010
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFB,0xF1,0x12,0xA4,0x69,0x0D,0x92,0x14,0xDA,0x21,0x94,0x39,0x84,0x05,0xCF,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//1011
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x9A,0x69,0xD8,0x65,0x43,0x21,0x96,0x8A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	//1100
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB7,0xBF,0x5A,0xA9,0x65,0xAD,0x60,0xC1,0x89,0x34,0x55,0x8E,0x1B,0x02,0x41,0x35,0x05,0x95,0x01,0xEE,0x00,0x00,0x00,0x00},
	//1101
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0xA6,0x31,0xCA,0x9B,0x35,0xDE,0xDD,0xE0,0x36,0x99,0x6A,0x7E,0xA3,0x06,0x8A,0x69,0x68,0xBB,0x49,0x00,0x00,0x00,0x00},
	//1110
	{0x13,0xec,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x97,0xEA,0x4D,0x3D,0x22,0x97,0x80,0x21,0x92,0x52,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
};


void hal_audio_init(void)
{
	SICK_0;	
    SISTRB_1;	
    SOSTRB_1;
	//写入信号和读取信号	
	//滑动，回声，激活打开	
	//采用被动串行方式	
	//采用默认采用2400bps速率
    hal_audio_reset();	
}

void hal_audio_reset(void)
{
	//重启
	AMBE_RST_1;
	delay_ms(100);
	AMBE_RST_0;
	delay_ms(10);
	AMBE_RST_1;
	delay_ms(100);
}

void hal_audio_read(uint8_t *buffer)
{
	uint8_t i, j, temp;
	uint8_t *ptr = buffer;
	
	for(i=0; i<AUDIO_FRAME_SIZE/2; i++)
	{
		SOSTRB_0;
		SOCK_0;
		temp = 0;
		for (j=0; j<8; j++)
		{
			SOCK_1;
			if (SDO_STATE)	temp |= 1u<<(7-j);
			SOCK_0;
		}
		*ptr++ = temp;
		SOSTRB_1;
		temp = 0;
		for (j=0; j<8; j++)
		{
			SOCK_1;
			if (SDO_STATE)	temp |= 1u<<(7-j);
			SOCK_0;            
		}
		*ptr++ = temp;
	}
}

void hal_audio_write(uint8_t *buffer)
{
	uint8_t i, j, temp;
	uint8_t *ptr = buffer;

	for(i=0; i<AUDIO_FRAME_SIZE/2; i++)
	{
		SISTRB_0;
		SICK_0;
        temp = 0;
		SICK_1;
		temp = *ptr++;
		for (j=0; j<8; j++)
		{
			SICK_0;
			if (temp&(1u<<(7-j)))
			{
				SDI_1;
			}
			else
			{
				SDI_0;
			}
			SICK_1;
		}
		SISTRB_1;
		temp = *ptr++;
		for (j=0; j<8; j++)
		{
			SICK_0;
			if (temp&(1u<<(7-j)))
			{
				SDI_1;
			}
			else
			{
				SDI_0;
			}
			SICK_1;
		}
	}
}

bool_t hal_audio_is_write(void)
{
    return DPE_PIN_STATE;
}

bool_t hal_audio_is_read(void)
{
    return EPR_PIN_STATE;
}

void hal_audio_set_rate(uint8_t rate)
{
	uint8_t buffer[AUDIO_FRAME_SIZE];
	
	mem_clr(buffer, AUDIO_FRAME_SIZE);
	buffer[0] = 0x13;
	buffer[1] = 0xec;
	buffer[2] = 0x01;	//ID
	buffer[3] = 0x00;	//Control_0

	switch (rate)
	{
	case VOICE_2400BPS_LEVEL:
		buffer[4] = 0x41;
		buffer[5] = 0x30;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 6;
		break;	
	case VOICE_2400BPS_FEC_LEVEL:
		buffer[4] = 0x41;
		buffer[5] = 0x30;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x01;	//Control_2
		audio_num_per_frm = 6;
		break;
	case VOICE_3600BPS_LEVEL:
		buffer[4] = 0x61;
		buffer[5] = 0x48;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 9;
		break;
	case VOICE_3600BPS_FEC_LEVEL:
		buffer[4] = 0x51;
		buffer[5] = 0x48;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x20;	//Control_2
		audio_num_per_frm = 9;
		break;
	case VOICE_4000BPS_LEVEL:
		buffer[4] = 0x61;
		buffer[5] = 0x50;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x20;	//Control_2
		audio_num_per_frm = 10;
		break;
	case VOICE_4800BPS_LEVEL:
		buffer[4] = 0xA3;
		buffer[5] = 0x60;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 12;
		break;
	case VOICE_4800BPS_FEC1_LEVEL:
		buffer[4] = 0xA3;
		buffer[5] = 0x60;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x20;	//Control_2
		audio_num_per_frm = 12;
		break;
	case VOICE_4800BPS_FEC2_LEVEL:
		buffer[4] = 0x61;
		buffer[5] = 0x60;	//Control_1
		buffer[6] = 0x90;
		buffer[7] = 0x06;	//Control_2
		audio_num_per_frm = 12;
		break;
	case VOICE_4800BPS_FEC3_LEVEL:
		buffer[4] = 0x51;
		buffer[5] = 0x60;	//Control_1
		buffer[6] = 0x94;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 12;
		break;
	case VOICE_6400BPS_LEVEL:
		buffer[4] = 0xA3;
		buffer[5] = 0x80;	//Control_1
		buffer[6] = 0x96;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 16;
		break;
	case VOICE_7200BPS_LEVEL:
		buffer[4] = 0xA3;
		buffer[5] = 0x90;	//Control_1
		buffer[6] = 0x98;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 18;
		break;
	case VOICE_8000BPS_LEVEL:
		buffer[4] = 0xE4;
		buffer[5] = 0xA0;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x20;	//Control_2
		audio_num_per_frm = 20;
		break;
	case VOICE_8000BPS_FEC_LEVEL:
		buffer[4] = 0xA3;
		buffer[5] = 0xA0;	//Control_1
		buffer[6] = 0x9A;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 20;
		break;
	case VOICE_9600BPS_LEVEL:
		buffer[4] = 0xE4;
		buffer[5] = 0xC0;	//Control_1
		buffer[6] = 0x00;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 24;
		break;
	case VOICE_9600BPS_FEC_LEVEL:
		buffer[4] = 0xA3;
		buffer[5] = 0xC0;	//Control_1
		buffer[6] = 0xF2;
		buffer[7] = 0x00;	//Control_2
		audio_num_per_frm = 24;
		break;
		default:return;
	}
	audio_rate = rate;
	hal_audio_write(buffer);
	delay_ms(200);
	hal_audio_write(buffer);
    delay_ms(200);
	hal_audio_write(buffer);
    delay_ms(200);
	hal_audio_write(buffer);
    delay_ms(200);
	hal_audio_write(buffer);
}

uint8_t hal_audio_get_rate(void)
{
	return audio_rate;
}

uint8_t hal_audio_get_valid_data_len(void)
{
	return audio_num_per_frm;
}

void hal_audio_change_gain(uint8_t level)
{
	uint8_t buffer[AUDIO_FRAME_SIZE];
	
	mem_clr(buffer, AUDIO_FRAME_SIZE);
	buffer[0] = 0x13;
	buffer[1] = 0xec;
	buffer[2] = 0x02;	//ID
	buffer[3] = 0x00;	//Control_0
	if (level == 3)
	{
		buffer[4] = 0xE5;
		buffer[5] = 0xFF;	//Control_1
	}
	else if (level == 2)
	{
		buffer[4] = 0xE5;
		buffer[5] = 0xC0;	//Control_1
	}
	else
	{
		buffer[4] = 0xE5;
		buffer[5] = 0x80;	//Control_1
	}		
	buffer[6] = 0x01;
	buffer[7] = 0xF4;	//Control_2
	
	hal_audio_write(buffer);
	delay_ms(200);
	hal_audio_write(buffer);
	delay_ms(200);
	hal_audio_write(buffer);
	delay_ms(200);
	hal_audio_write(buffer);
	delay_ms(200);
	hal_audio_write(buffer);
}

bool_t hal_audio_is_ptt(void)
{
	if (dev_type == HANDSET)
	{		
		//低电平表示按下
		if (hal_gpio_input(HD_KEY_1) == 0)	//HD_KEY_0
		{
			return PLAT_TRUE;
		}
		else
		{
			return PLAT_FALSE;
		}
	}
	
	return PLAT_FALSE;
}

void hal_audio_deinit(void)
{
	AMBE_RST_0;	
}

